# 출처 : [Python Asyncio를 활용한 효율적인 광고데이터 수집](https://tech.madup.com/python-asyncio-intro/)

## asyncio vs multi-threading

동시에 여러 개의 작업을 실행해야 할 때 많이 사용하는 다른 방법에는 새로운 스레드를 생성하여 병렬로 실행하는 멀티스레딩이 있습니다.

스레딩과 asyncio 사이에 존재하는 근본적인 차이에 대해 이야기 해보고자 합니다.
스레드는 OS에서 제공하는 기능이며 한 프로세스 내에서 코드를 병렬로 실행하고자 할 때 사용합니다.
이때 각 스레드는 다른 CPU 코어에서 실행될 수 있습니다. 즉 물리적으로 병렬(parallel) 처리가 이뤄집니다.
그래서 계산량이 많은 작업을 병렬로 나눠서 처리할 때도 많이 사용합니다.
하지만 파이썬에서는 GIL(Global Interpreter Lock)이라는 존재 때문에 한 번에 하나의 바이트코드만 실행할 수 있기 때문에 이러한 병렬성에 제한이 있습니다.

asyncio는 OS가 아닌 프로그램 영역에서 제공하는 기능입니다.
하나의 스레드에서 이벤트 루프를 만들고 코루틴 또는 태스크라고 하는 것들을 번갈아가면서 실행하는 것입니다.
스레드처럼 물리적으로 병렬 처리하는 것은 아니기 때문에 asyncio를 사용한다고 해서 계산상의 이점은 없습니다.
대신 asyncio는 I/O가 발생할 때 block 하지 않고 다른 코루틴, 태스크를 실행할 수 있도록 스케줄링 해주기 때문에 여러 I/O 작업들이 동시에(concurrent) 실행되는 것처럼 느끼게 해주는 것입니다.

## asyncio 장점 2가지
1. 멀티스레딩에서 경합조건을 피할 수 있다.
    - 멀티스레딩은 스레드를 물리적으로 병렬로 실행하기 때문에 공유자원을 동시에 접근하는 경우 경합조건이라는 문제가 생길 수 있다.
    - 하지만 asyncio는 이벤트 루프를 통한 논리적인 동시 실행이기 때문에 경합조건을 피할 수 있다.

2. 적은 자원 사용량
    - 스레드는 생성될 때 별도의 스택 메모리 공간을 할당하여 사용하지만, asyncio는 단일 스레드에서 실행되기 때문에 별도의 스택 메모리 공간이 필요하지 않습니다.
    - 스레드 개수가 CPU 코어보다 많기 때문에 계속해서 context switching이 발생하게 됩니다. 이러한 context switching은 스레드가 I/O로 인해 block 된 상태에서도 계속해서 발생하며, OS는 이러한 스레드들을 관리하고 스케줄링 하는데 시간과 자원을 사용하게 됩니다. asyncio는 단일 스레드에서 실행되기 때문에 이러한 스레드 간의 context switching이 필요하지 않으며, select, poll, epoll과 같은 시스템 콜을 통해 실행 재개가 필요한지를 확인할 수 있어 효율적으로 코루틴 간의 실행을 전환할 수 있습니다.